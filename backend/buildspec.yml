version: 0.2
env:
  privilegedMode: true
  variables:
    AWS_REGION: "ap-southeast-2"
    AWS_APPLICATION_NAME: "Lab17-App"
    AWS_DEPLOYMENT_GROUP_NAME: "Lab17-DeploymentGroup"
    SERVICE_NAME: "Lab17-Service"    
    TASK_FAMILY: "VPC2-Task-Backend-Lab17-03-withDBinfo-backendLab17-ALB:2"
phases:
  pre_build:
    commands:
      - export AWS_REGION="ap-southeast-2"
      - export AWS_APPLICATION_NAME="Lab17-App"
      - export AWS_DEPLOYMENT_GROUP_NAME="Lab17-DeploymentGroup"
      # Debug: Check all environment variables
      # - echo "AWS_REGION: '${AWS_REGION}'"
      # - echo "AWS_APPLICATION_NAME: '${AWS_APPLICATION_NAME}'"
      # - echo "AWS_DEPLOYMENT_GROUP_NAME: '${AWS_DEPLOYMENT_GROUP_NAME}'"
      # Login to Amazon ECR
      - aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_NUMBER}.dkr.ecr.${AWS_REGION}.amazonaws.com
      # Set the image tag using CodeBuild source version
      - IMAGE_TAG=${CODEBUILD_RESOLVED_SOURCE_VERSION}
      # Set the full URI for the Docker image
      - IMAGE_URI=${AWS_ACCOUNT_NUMBER}.dkr.ecr.${AWS_REGION}.amazonaws.com/${CI_PROJECT_BE_NAME}:${IMAGE_TAG}
  
  build:
    commands:
      # Navigate to backend directory and build Docker image
      - cd backend
      - docker build -f Dockerfile -t ${IMAGE_URI} .
      
  post_build:
    commands:
      # Push the Docker image to ECR
      - docker push ${IMAGE_URI}
    # Ensure service exists before deployment
      - |
        if ! aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --region $AWS_REGION --query 'services[?status==`ACTIVE`]' --output text | grep -q .; then
          echo "Service doesn't exist. Creating..."
          aws ecs create-service \
            --cluster $CLUSTER_NAME \
            --service-name $SERVICE_NAME \
            --task-definition $TASK_FAMILY \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SECURITY_GROUP_IDS],assignPublicIp=ENABLED}"\
            --region $AWS_REGION
          # Wait for service to be stable
          aws ecs wait services-stable --cluster $CLUSTER_NAME --services $SERVICE_NAME --region $AWS_REGION
        fi
    # Update service with new task definition
      - NEW_TASK_DEF_ARN=$(echo $NEW_REVISION | jq -r '.taskDefinition.taskDefinitionArn')
      - aws ecs update-service --cluster $CLUSTER_NAME --service $SERVICE_NAME --task-definition $NEW_TASK_DEF_ARN --region $AWS_REGION --force-new-deployment  
      # Get the current task definition from ECS
      - TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition ${TASK_NAME_BE} --region ${AWS_REGION})
      # Create new task definition with updated image
      - NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "${IMAGE_URI}" '.taskDefinition | .containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
      - NEW_REVISION=$(aws ecs register-task-definition --region ${AWS_REGION} --cli-input-json "$NEW_TASK_DEFINITION")
      
      # Extract required information for AppSpec
      - AWS_TASK_DEFINITION_ARN=$(echo $TASK_DEFINITION | jq -r '.taskDefinition.taskDefinitionArn')
      - CONTAINER_NAME=$(echo $TASK_DEFINITION | jq -r '.taskDefinition.containerDefinitions[0].name')
      - CONTAINER_PORT=$(echo $TASK_DEFINITION | jq -r '.taskDefinition.containerDefinitions[0].portMappings[0].containerPort')
      
      # Create AppSpec content for CodeDeploy Blue/Green deployment
      - |
        APP_SPEC=$(jq -n --arg taskDef "$AWS_TASK_DEFINITION_ARN" --arg containerName "$CONTAINER_NAME" --argjson containerPort "$CONTAINER_PORT" '{
          version: "0.0",
          Resources: [
            {
              TargetService: {
                Type: "AWS::ECS::Service",
                Properties: {
                  TaskDefinition: $taskDef,
                  LoadBalancerInfo: {
                    ContainerName: $containerName,
                    ContainerPort: $containerPort
                  }
                }
              }
            }
          ]
        }')
      
      # Create deployment revision with AppSpec content
      - |
        REVISION=$(jq -n --arg appSpec "$APP_SPEC" '{
          revisionType: "AppSpecContent",
          appSpecContent: {
            content: $appSpec
          }
        }')
      - printf '{"ImageURI":"%s"}' $IMAGE_URI > imageDetail.json
      # Create new deployment in CodeDeploy
      - aws deploy create-deployment --region ${AWS_REGION} --application-name ${AWS_APPLICATION_NAME} --deployment-group-name ${AWS_DEPLOYMENT_GROUP_NAME} --revision "$REVISION"

artifacts:
  files:
    - imageDetail.json
